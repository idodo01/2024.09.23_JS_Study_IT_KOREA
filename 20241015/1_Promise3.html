<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    //// 프로미스의 정적 메서드

    // 1. Promise.resolve: 인수로 전달받은 값을 resolve 하는 프로미스를 생성함
    // => Promise 객체 안에서 resolve()를 실행했다는 뜻!
    // => fullfiled

    // 성공시
    const promise1 = Promise.resolve([1,2,3]); // [1,2,3]은 비동기 실행의 성공 결과물이다!
    promise1.then((value) => {
        console.log(value)
    });

    // 실패시
    const promise2 = Promise.reject([1,2,3]); // [1,2,3]은 비동기 실행의 성공 결과물이다!
    promise2.catch((e) => {
        console.log(e)
    });

    ////////////////////////////////////////////////////////////////////

    // 2. Promise.all
    // 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용함
    const p1 = new Promise( (resolve) => {
        setTimeout( () => {
            resolve(1);
        }, 3000);
    } );
    const p2 = new Promise( (resolve) => {
        setTimeout( () => {
            resolve(2);
        }, 2000);
    } );
    const p3 = new Promise( (resolve) => {
        setTimeout( () => {
            resolve(3);
        }, 1000);
    } );

    // Promise.all()

// =====================> 즉시 함수 사용으로 바꿈

    /// Promise.all
    // 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용함
    const p1 = () => new Promise( (resolve) => {
        setTimeout( () => {
            resolve(1);
        }, 3000);
    } );

    // 실행 방법
    p1();

    const p2 = () => new Promise( (resolve) => {
        setTimeout( () => {
            resolve(2);
        }, 2000);
    } );
    const p3 = () => new Promise( (resolve) => {
        setTimeout( () => {
            resolve(3);
        }, 1000);
    } );


    // p1().then(value => {
    //     console.log(value);
    //
    //     p2().then(value1 => {
    //         console.log(value1);
    //     });
    //
    // });

    // 일반적인 프로미스 체이닝(Promise Chaining)
    //
    // p1().then(value => {
    //     console.log(value);
    //     // 프로미스 실행에서 프로미스를 return
    //     return p2(); // 현재 프로미스의 후속 동작으로 변함
    // }).then(value => {      // p2의 then
    //     console.log(value);
    //     return p3();
    // }).then(value => {      // p3의 then
    //     console.log(value);
    // })


    //all은 배열 등의 이터러블(순회 가능한) 요소를 전달할 수 있음
    // p1, p2, p3 프로미스는 동시 실행이 되고, 모든 프로미스가 fulfilled(성공 종료)가 되면 종료
    // p1, p2, p3에서 resolve 되었던 실행 결과를 전부 배열에 담아서 value에 전달함

    Promise.all([p1(), p2(), p3()])
    .then(value => {
        console.log(value);
    });

    /************************************************************/
    // 3. Promise.race(): 모든 프로미스가 fulfilled(성공 종료) 상태가 되는 것이 기다리는 게 아니라,
    // 가장 먼저 fulfilled 된 프로미스의 처리 결과를 가져오고 종료한다
    Promise.race([p1(),p2(),p3()])
        .then(console.log);

    /************************************************************/
    // 4. Promise.allSetteled
    // 전달받은 프로미스가 모두 settled상태(성공, 실패 상관없이 종료된 상태)가 되면
    // 결과를 배열로 반환한다
    const _ = 1 // 안쓰는 변수를 _로 표기한다
    Promise.allSettled([
        new Promise(resolve => setTimeout(() => resolve('성공~')), 2000),
        new Promise((_, reject) => setTimeout(() => reject('실패ㅠ'), 1000))
    ])
        .then(console.log);




    ///////////////////////////////////////////////////
</script>